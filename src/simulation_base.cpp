#include "../include/simulation_base.h"#include <math.h>#include <ctime>#include <iostream>#include <fstream>#include <sstream>#include <boost/random/uniform_int_distribution.hpp>#include <boost/random/uniform_01.hpp>#include "../include/quaternion.h"static bool readProperties(std::string typeName, Ptype &ptype, double scale);double simulationBase::mtRandd(double x, bool isSymmetric)const{	static boost::random::uniform_01<boost::mt19937> mtUniReal(randGen_);	return isSymmetric? x * (2.0 * mtUniReal() - 1.0) : x * mtUniReal();}int simulationBase::mtRandi(int x){	static boost::random::uniform_int_distribution<> mtUniInt(0);	return mtUniInt(randGen_) % x;}bool simulationBase::Init(int argc, char *argv[]){	randGen_.seed(std::time(0));	if(!readConfiguration(argv[1])) return false;	return true;}bool simulationBase::readConfiguration(const char *filepath){	unsigned int nTypes;	std::vector<quat_t> rotations;		std::ifstream file(filepath);	if(!file){		std::cout << "Error parsing file \"" << filepath << "\" by function " << "'" << __FUNCTION__ << "'" << std::endl;		return false;	}		std::cout << "Parsing Configuration File: '" << std::string(filepath) << "'" << std::endl;		std::string line;	std::getline(file, line);	std::istringstream s(line);		//Read number of particles	s >> nPart_;	std::cout << "Found " << nPart_ << " particles." << std::endl;		s.clear();	std::getline(file, line);	s.str(line);		//Read number of particle types	s >> nTypes;		s.clear();	std::getline(file, line);	s.str(line);		//Read Box properties	for(unsigned int i = 0; i < 9; i++) s >> box_[i];			//Read Particle position, type and rotation	for(unsigned int i = 0; i < nPart_; i++){		std::getline(file, line);		std::istringstream stream(line);		Particle tempParticle;		quat_t tempRot;		stream >> tempParticle.type >> std::ws;		stream >> tempParticle.pos[0] >> tempParticle.pos[1] >> tempParticle.pos[2] >> std::ws;		stream >> tempRot.el[0] >> tempRot.el[1] >> tempRot.el[2] >> tempRot.el[3] >> std::ws;		rotations.push_back(tempRot);		tempParticle.index = i;		particles_.push_back(tempParticle);	}		//Read type names and initiate types	for(unsigned int i = 0; i < nTypes; i++){		std::getline(file, line);		std::istringstream stream(line);		std::string typeName;		double scale = 1.0;		stream >> typeName >> std::ws;		if(!stream.eof()) stream >> scale >> std::ws;		Ptype tempType;		if(typeName != "Sphere"){			if(!readProperties(typeName, tempType, scale)) return false;		}		else tempType.name = "Sphere";		types_.push_back(tempType);	}		//Rotate each particle's vertices acording to the rotations read from the input file	//Also find the maximum circumscribed radius or just radius in case of spheres	double max = 0.0;	for(unsigned int i = 0; i < nPart_; i++){		unsigned int partType = particles_[i].type;		if(types_[partType].name != "Sphere"){			particles_[i].vertices = types_[partType].vertices;			std::vector<clam::vec3d>::iterator itr;			for(itr = particles_[i].vertices.begin(); itr < particles_[i].vertices.end(); itr++){				quat_rot(rotations[i], *itr);			}			if(particles_[i].scale * sqrt(types_[partType].cscrb_d2) > max) max = sqrt(types_[partType].cscrb_d2);		}		else if(2.0 * particles_[i].scale > max) max = 2.0 * particles_[i].scale;	}	Rmax_ = max;	std::cout << "Successfully done parsing." << std::endl;	std::cout << std::endl;	return true;}static bool readProperties(std::string typeName, Ptype &ptype, double scale = 1.0){	std::cout << "Parsing Properties for " << typeName << "." << std::endl;	ptype.name = typeName;	std::vector<clam::vec3d> vertices;	std::vector< std::vector<unsigned int> > faces;	std::vector< std::vector<unsigned int> > edges;	std::vector< std::vector<unsigned int> > vertNeigh;		/* Parse File */	const char *filepath = ("obj/" + typeName + ".obj").c_str();	std::ifstream file(filepath);	if(!file){		std::cout << "Error parsing file \"" << filepath << "\" by function " << "'" << __FUNCTION__ << "'" << std::endl;		return false;	}		std::string line;	while(std::getline(file, line)){		if(line[0] == 'v'){			std::istringstream s(line.substr(2));			clam::vec3d vertex;			s >> vertex[0] >> vertex[1] >> vertex[2] >> std::ws;			for(int i = 0; i < 3; i++) vertex[i] *= scale;			vertices.push_back(vertex);		}		else if(line[0] == 'f'){			std::istringstream s(line.substr(2));			std::vector<unsigned int> face;			unsigned int faceVertexIndex;			while(s >> faceVertexIndex) face.push_back(faceVertexIndex - 1);			faces.push_back(face);		}	}	file.close();	ptype.vertices = vertices;	std::cout << "Found " << vertices.size() << " vertices." << std::endl;		/* Calculate Properties */		//Find Edges	std::vector< std::vector<unsigned int> >::iterator faceItr1, faceItr2;	//Iterate over each face and for each next face in the list, check if they 	//share two vertices, this defines an edge.	for(faceItr1 = faces.begin(); faceItr1 < faces.end(); faceItr1++){		for(faceItr2 = faceItr1 + 1; faceItr2 < faces.end(); faceItr2++){			unsigned int fcount = 0;			std::vector<unsigned int> edge;			std::vector<unsigned int>::iterator itr1, itr2;			for(itr1 = (*faceItr1).begin(); itr1 < (*faceItr1).end(); itr1++){				for(itr2 = (*faceItr2).begin(); itr2 < (*faceItr2).end(); itr2++){					if(*itr1 == *itr2){						edge.push_back(*itr1);						fcount++;					}				}				if(fcount == 2){					edges.push_back(edge);					fcount = 0;					edge.clear();				}			}		}	}	std::cout << "Found " << edges.size() << " edges." << std::endl;		//Find Vertex Neighbours	//For all vertices, check if two edges share this vertex. If they do and it	//isn't vertex 0, append the other vertices of these edge to the neighbor list	for(unsigned int vi = 0; vi < vertices.size(); vi++){		std::vector<unsigned int> neighbors;		for(unsigned int ei = 0; ei < edges.size(); ei++){			for(unsigned int i = 0; i < 2; i++){				if(edges[ei][i] == vi){					if(edges[ei][(i+1)%2] != 0) neighbors.push_back(edges[ei][(i+1)%2]);				}			}		}		if(!neighbors.empty()) vertNeigh.push_back(neighbors);	}	ptype.vertNeigh = vertNeigh;		//Find the inRadius	//For each face, calculate its distance from the particle's center and find the min	std::vector< std::vector<unsigned int> >::iterator faceItr;	double minDistance = 100.0;	for(faceItr = faces.begin(); faceItr < faces.end(); faceItr++){		clam::vec3d p(vertices[(*faceItr)[0]]);				clam::vec3d a(			vertices[(*faceItr)[1]][0] - vertices[(*faceItr)[0]][0],			vertices[(*faceItr)[1]][1] - vertices[(*faceItr)[0]][1],			vertices[(*faceItr)[1]][2] - vertices[(*faceItr)[0]][2]		);				clam::vec3d b(			vertices[(*faceItr)[2]][0] - vertices[(*faceItr)[0]][0],			vertices[(*faceItr)[2]][1] - vertices[(*faceItr)[0]][1],			vertices[(*faceItr)[2]][2] - vertices[(*faceItr)[0]][2]		);				clam::vec3d normal = a.cross(b);		double length = clam::length(normal);		for(int i = 0; i < 3; i++) normal[i] /= length;		double faceDistance = fabs(clam::dot(normal, p));				if(faceDistance < minDistance) minDistance = faceDistance;	}	ptype.iscrb_d2 = 4.0 * (minDistance * minDistance);	std::cout << "Square of Inscribed Diameter: " << ptype.iscrb_d2 << std::endl;		//Find the circumRadius	//It's just the farthest vertex from the particle's center	double maxDistance = 0.0;	std::vector<clam::vec3d>::iterator vItr;	for(vItr = vertices.begin(); vItr < vertices.end(); vItr++){		double vertexLength = clam::length(*vItr);		if( vertexLength > maxDistance) maxDistance = vertexLength;	}	ptype.cscrb_d2 = 4.0 * (maxDistance * maxDistance);	std::cout << "Square of Circumscribed Diameter: " << ptype.cscrb_d2 << std::endl;		//Find two linearly independent vertices	ptype.triadV1 = 0;	for(unsigned int i = 1; i < vertices.size(); i++){		double crossLength = clam::length(vertices[0].cross(vertices[i]));		if(crossLength > 1.0e-10){			ptype.triadV2 = i;			break;		}	}	std::cout << std::endl;		return true;}