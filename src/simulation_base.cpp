#include "../include/simulation_base.h"#include <math.h>#include <iostream>#include <fstream>#include <sstream>double simulationBase::mtRandd(double x, bool isSymmetric)const{	return isSymmetric?x*(2.0*dsfmt_genrand_open_open(&dsfmt_)-1.0):x*dsfmt_genrand_open_open(&dsfmt_);}int simulationBase::mtRandi(int x)const{	return dsfmt_genrand_uint32(&dsfmt_)%x;}static bool readProperties(const char *filepath, Ptype &ptype, double scale = 1.0){	std::vector<clam::vec3d> vertices;	std::vector< std::vector<unsigned int> > faces;	std::vector< std::vector<unsigned int> > edges;	std::vector< std::vector<unsigned int> > vertNeigh;		/* Parse File */	std::ifstream file(filepath);	if(!file){		std::cout << "Error parsing file \"" << filepath << "\" by function " << "'" << __FUNCTION__ << "'" << std::endl;		return false;	}		std::string line;	while(std::getline(file, line)){		if(line[0] == 'v'){			std::istringstream s(line.substr(2));			clam::vec3d vertex;			s >> vertex[0] >> vertex[1] >> vertex[2] >> std::ws;			for(int i = 0; i < 3; i++) vertex[i] *= scale;			vertices.push_back(vertex);		}		else if(line[0] == 'f'){			std::istringstream s(line.substr(2));			std::vector<unsigned int> face;			unsigned int faceVertexIndex;			while(s >> faceVertexIndex) face.push_back(faceVertexIndex - 1);			faces.push_back(face);		}	}	file.close();	ptype.vertices = vertices;		/* Calculate Properties */		//Find Edges	std::vector< std::vector<unsigned int> >::iterator faceItr1, faceItr2;	//Iterate over each face and for each next face in the list, check if they 	//share two vertices, this defines an edge.	for(faceItr1 = faces.begin(); faceItr1 < faces.end(); faceItr1++){		for(faceItr2 = faceItr1 + 1; faceItr2 < faces.end(); faceItr2++){			unsigned int fcount = 0;			std::vector<unsigned int> edge;			std::vector<unsigned int>::iterator itr1, itr2;			for(itr1 = (*faceItr1).begin(); itr1 < (*faceItr1).end(); itr1++){				for(itr2 = (*faceItr2).begin(); itr2 < (*faceItr2).end(); itr2++){					if(*itr1 == *itr2){						edge.push_back(*itr1);						fcount++;					}				}				if(fcount == 2){					edges.push_back(edge);					fcount = 0;					edge.clear();				}			}		}	}		//Find Vertex Neighbours	//For all vertices, check if two edges share this vertex. If they do and it	//isn't vertex 0, append the other vertices of these edge to the neighbor list	for(unsigned int vi = 0; vi < vertices.size(); vi++){		std::vector<unsigned int> neighbors;		for(unsigned int ei = 0; ei < edges.size(); ei++){			for(unsigned int i = 0; i < 2; i++){				if(edges[ei][i] == vi){					if(edges[ei][(i+1)%2] != 0) neighbors.push_back(edges[ei][(i+1)%2]);				}			}		}		if(!neighbors.empty()) vertNeigh.push_back(neighbors);	}	ptype.vertNeigh = vertNeigh;		//Find the inRadius	//For each face, calculate its distance from the particle's center and find the min	std::vector< std::vector<unsigned int> >::iterator faceItr;	double minDistance = 100.0;	for(faceItr = faces.begin(); faceItr < faces.end(); faceItr++){		clam::vec3d p(vertices[(*faceItr)[0]]);				clam::vec3d a(			vertices[(*faceItr)[1]][0] - vertices[(*faceItr)[0]][0],			vertices[(*faceItr)[1]][1] - vertices[(*faceItr)[0]][1],			vertices[(*faceItr)[1]][2] - vertices[(*faceItr)[0]][2]		);				clam::vec3d b(			vertices[(*faceItr)[2]][0] - vertices[(*faceItr)[0]][0],			vertices[(*faceItr)[2]][1] - vertices[(*faceItr)[0]][1],			vertices[(*faceItr)[2]][2] - vertices[(*faceItr)[0]][2]		);				clam::vec3d normal = a.cross(b);		double length = clam::length(normal);		for(int i = 0; i < 3; i++) normal[i] /= length;		double faceDistance = fabs(clam::dot(normal, p));				if(faceDistance < minDistance) minDistance = faceDistance;	}	ptype.iscrb_d2 = 4.0 * (minDistance * minDistance);		//Find the circumRadius	//It's just the farthest vertex from the particle's center	double maxDistance = 0.0;	std::vector<clam::vec3d>::iterator vItr;	for(vItr = vertices.begin(); vItr < vertices.end(); vItr++){		double vertexLength = clam::length(*vItr);		if( vertexLength > maxDistance) maxDistance = vertexLength;	}	ptype.cscrb_d2 = 4.0 * (maxDistance * maxDistance);		//Find two linearly independent vertices	ptype.triadV1 = 0;	for(unsigned int i = 1; i < vertices.size(); i++){		double crossLength = clam::length(vertices[0].cross(vertices[i]));		if(crossLength > 1.0e-10){			ptype.triadV2 = i;			break;		}	}		return true;}